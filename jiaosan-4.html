<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>å…¨èƒ½ç„¦æ•£æ¨¡æ‹Ÿå™¨ (Universal Caustics)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* UI ç•Œé¢ */
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #444; border-radius: 12px;
            padding: 20px; width: 340px;
            color: #eee;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        h2 { margin: 0 0 15px 0; font-size: 18px; color: #4db8ff; border-bottom: 1px solid #444; padding-bottom: 10px; }
        
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        button {
            padding: 10px; border: none; border-radius: 6px;
            background: #333; color: #aaa; cursor: pointer;
            font-size: 13px; transition: all 0.2s;
        }
        button:hover { background: #444; color: #fff; }
        button.active { background: #4db8ff; color: #000; font-weight: bold; box-shadow: 0 0 15px rgba(77, 184, 255, 0.3); }

        .desc { font-size: 13px; line-height: 1.5; color: #ccc; min-height: 80px; }
        .highlight { color: #ffeb3b; font-weight: bold; }
        .instruction { margin-top: 10px; font-size: 12px; color: #888; font-style: italic; border-top: 1px solid #333; padding-top: 10px; }
    </style>
</head>
<body>

<div id="ui">
    <h2>ç„¦æ•£å®éªŒå®¤</h2>
    <div class="grid">
        <button onclick="setMode(0)" class="active" id="btn0">1. åå°„ (å’–å•¡æ¯)</button>
        <button onclick="setMode(1)" id="btn1">2. æŠ˜å°„ (é€é•œ)</button>
        <button onclick="setMode(2)" id="btn2">3. è‰²æ•£ (æ£±é•œ)</button>
        <button onclick="setMode(3)" id="btn3">4. æ°´é¢ (æ³¢çº¹)</button>
    </div>
    <div id="description" class="desc"></div>
    <div class="instruction">ğŸ’¡ æç¤ºï¼šåœ¨å±å¹•ä¸Šç§»åŠ¨é¼ æ ‡/æ‰‹æŒ‡å¯ä»¥æ§åˆ¶å…‰æºä½ç½®ã€‚</div>
</div>

<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const descEl = document.getElementById('description');
    
    let width, height;
    let mode = 0; // å½“å‰æ¨¡å¼
    let mouseX = window.innerWidth / 2;
    let mouseY = window.innerHeight / 2;
    let time = 0;

    // åœºæ™¯é…ç½®æ•°æ®
    const scenes = [
        {
            title: "åå°„ç„¦æ•£ (Catacaustics)",
            desc: "è¿™æ˜¯å…‰çº¿æ‰“åœ¨å¼¯æ›²é•œé¢ï¼ˆå¦‚å’–å•¡æ¯å†…å£ã€é‡‘å±æˆ’æŒ‡ï¼‰ä¸Šåå°„å½¢æˆçš„ã€‚<br><br>æ³¨æ„è§‚å¯Ÿé‚£ä¸ª<span class='highlight'>å¿ƒå½¢ (Cardioid)</span> çš„å…‰æ–‘å°–ç«¯ã€‚è¿™ä¸éœ€è¦é€æ˜ç‰©ä½“ï¼Œåªè¦æœ‰åå…‰å†…å£å°±ä¼šå‡ºç°ã€‚",
            color: '255, 200, 100' // é‡‘è‰²
        },
        {
            title: "æŠ˜å°„ç„¦æ•£ (Diacaustics)",
            desc: "è¿™æ˜¯å…‰çº¿ç©¿è¿‡å‡¸é€é•œï¼ˆå¦‚ç»ç’ƒçƒã€æ”¾å¤§é•œï¼‰æ±‡èšå½¢æˆçš„ã€‚<br><br>å…‰çº¿è¢«'æŒ¤'åˆ°äº†ä¸€ä¸ªç„¦ç‚¹ä¸Šã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæ”¾å¤§é•œèƒ½ç‚¹ç«â€”â€”èƒ½é‡å¯†åº¦åœ¨è¿™é‡Œæ˜¯æ— é™å¤§çš„ã€‚",
            color: '100, 200, 255' // è“è‰²
        },
        {
            title: "è‰²æ•£ç„¦æ•£ (Dispersion)",
            desc: "è¿™æ˜¯é’»çŸ³å’Œå½©è™¹çš„åŸç†ã€‚ä¸åŒé¢œè‰²çš„å…‰æŠ˜å°„ç‡ä¸åŒï¼ˆè“å…‰å¼¯å¾—æ¯”çº¢å…‰æ€¥ï¼‰ã€‚<br><br>åŸæœ¬ç™½è‰²çš„ç„¦æ•£è¢«<span class='highlight'>æ‹†è§£</span>æˆäº†å…‰è°±ï¼Œè¾¹ç¼˜å‡ºç°äº†å½©è™¹è‰²ã€‚",
            color: '255, 255, 255' // ç™½è‰²(ä½†ä¼šæ‹†åˆ†)
        },
        {
            title: "æ°´é¢ç„¦æ•£ (Water Ripples)",
            desc: "è¿™æ˜¯å…‰çº¿ç©¿è¿‡èµ·ä¼ä¸å¹³çš„æ°´é¢é€ æˆçš„ã€‚<br><br>æ¯ä¸ªæ³¢å³°éƒ½åƒä¸€ä¸ªå°é€é•œï¼ŒæŠŠå…‰èšåˆ°åº•éƒ¨ã€‚æ— æ•°ä¸ªéšæœºç§»åŠ¨çš„èšç„¦ç‚¹å½¢æˆäº†ä¸€å¼ <span class='highlight'>åŠ¨æ€çš„å…‰ç½‘</span>ã€‚",
            color: '0, 255, 255' // é’è‰²
        }
    ];

    // åˆå§‹åŒ–
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
    window.addEventListener('touchmove', e => { mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY; });
    resize();
    updateUI();

    function setMode(m) {
        mode = m;
        document.querySelectorAll('button').forEach((b, i) => {
            b.className = i === m ? 'active' : '';
        });
        updateUI();
    }

    function updateUI() {
        descEl.innerHTML = scenes[mode].desc;
    }

    // ================== æ ¸å¿ƒæ¸²æŸ“å¾ªç¯ ==================
    function loop() {
        time += 0.01;
        
        // æ¸…ç©ºç”»å¸ƒ (å¸¦ä¸€ç‚¹æ‹–å°¾æ•ˆæœï¼Œæ›´æœ‰å…‰æ„Ÿ)
        ctx.fillStyle = 'rgba(5, 5, 5, 1)';
        ctx.fillRect(0, 0, width, height);

        // é€šç”¨ï¼šå¯ç”¨ã€å˜äº®ã€‘æ··åˆæ¨¡å¼ï¼Œè¿™æ˜¯æ¨¡æ‹Ÿå…‰çš„ç‰©ç†å åŠ çš„å…³é”®
        ctx.globalCompositeOperation = 'lighter';

        switch(mode) {
            case 0: drawReflection(); break;
            case 1: drawRefraction(); break;
            case 2: drawDispersion(); break;
            case 3: drawWater(); break;
        }

        // æ¢å¤é»˜è®¤
        ctx.globalCompositeOperation = 'source-over';
        requestAnimationFrame(loop);
    }
    loop();

    // ================== åœºæ™¯ 1: åå°„ (å’–å•¡æ¯å¿ƒå½¢) ==================
    function drawReflection() {
        const cx = width/2;
        const cy = height/2 + 50;
        const radius = Math.min(width, height) * 0.25;

        // 1. ç”»å‡ºâ€œå’–å•¡æ¯â€è¾¹ç¼˜ï¼ˆåŠåœ†ï¼‰
        ctx.beginPath();
        ctx.arc(cx, cy, radius, Math.PI, 0); // ä¸ŠåŠåœ†
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 5;
        ctx.stroke();

        // 2. å‘å°„å¹³è¡Œå…‰ (ä»å·¦è¾¹å°„å…¥ï¼Œä¹Ÿå¯ä»¥éšé¼ æ ‡æ”¹å˜è§’åº¦)
        const rayCount = 400;
        const lightAngle = (mouseX - width/2) * 0.002; // é¼ æ ‡æ§åˆ¶å…¥å°„è§’
        
        ctx.lineWidth = 1;
        ctx.strokeStyle = `rgba(${scenes[0].color}, 0.08)`; // éå¸¸é€æ˜çš„å…‰çº¿

        for (let i = 0; i < rayCount; i++) {
            // å¹³è¡Œå…‰æŸå®½åº¦
            let offset = (i / rayCount - 0.5) * radius * 2;
            
            // å…‰çº¿èµ·ç‚¹ (è¿œå¤„)
            let sx = cx + offset * Math.cos(lightAngle) - Math.sin(lightAngle) * 800;
            let sy = cy + offset * Math.sin(lightAngle) + Math.cos(lightAngle) * 800;
            
            // ç®€å•çš„æ•°å­¦æ¨¡å‹ï¼šå…‰çº¿å‡»ä¸­åœ†å†…å£
            // è¿™é‡Œä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬å‡è®¾å…‰çº¿æ˜¯å‚ç›´å°„å‘åœ†å¼€å£çš„
            // å®é™…è®¡ç®—éœ€è¦è§£ç›´çº¿ä¸åœ†çš„æ–¹ç¨‹ï¼Œè¿™é‡Œç®€åŒ–æ¼”ç¤ºå¿ƒå½¢çº¿åŸç†
            
            // æˆ‘ä»¬ç›´æ¥åœ¨åœ†å‘¨ä¸Šå–ç‚¹ä½œä¸ºåå°„ç‚¹
            let angle = Math.PI + (i / rayCount) * Math.PI; // åŠåœ†ä¸Šçš„ç‚¹
            let rx = cx + radius * Math.cos(angle);
            let ry = cy + radius * Math.sin(angle);

            // åªæœ‰å½“å…¥å°„å…‰è§’åº¦åˆé€‚æ—¶æ‰ç”»å…¥å°„çº¿(ç®€åŒ–)
            // è¿™é‡Œä¸»è¦ç”»åå°„çº¿ï¼Œå› ä¸ºç„¦æ•£æ˜¯åå°„çº¿å½¢æˆçš„
            
            // æ ¸å¿ƒï¼šåå°„å®šå¾‹
            // å…¥å°„å…‰å‡è®¾æ˜¯æ°´å¹³å‘å³ (ä¸ºäº†å½¢æˆå®Œç¾å¿ƒå½¢)
            // çœŸå®çš„å…¥å°„å…‰æ˜¯éšé¼ æ ‡çš„ï¼Œè¿™é‡Œä¸ºäº†è§†è§‰æ•ˆæœï¼Œè®©å…‰çº¿æ‰“æ»¡æ•´ä¸ªåŠåœ†
            
            // è®¡ç®—æ³•çº¿è§’åº¦
            let normalAngle = angle;
            // å‡è®¾å¹³è¡Œå…‰æ°´å¹³å°„å…¥ (0åº¦)
            let incidentAngle = 0; 
            
            // ç¨å¾®éšé¼ æ ‡åè½¬ä¸€ä¸‹å¹³è¡Œå…‰æ–¹å‘
            let lightDir = (mouseX - width/2) * 0.005;
            incidentAngle = lightDir;

            // åå°„è§’ = 2 * æ³•çº¿è§’ - å…¥å°„è§’ - PI
            let reflectAngle = 2 * normalAngle - incidentAngle - Math.PI;

            // ç»˜åˆ¶
            ctx.beginPath();
            // å…¥å°„å…‰ (ç”»çŸ­ä¸€ç‚¹æ„æ€ä¸€ä¸‹)
            ctx.moveTo(rx - Math.cos(incidentAngle)*200, ry - Math.sin(incidentAngle)*200);
            ctx.lineTo(rx, ry);
            // åå°„çº¿ (è¿™æ‰æ˜¯å½¢æˆç„¦æ•£çš„å…³é”®)
            ctx.lineTo(rx + Math.cos(reflectAngle) * radius * 2.5, ry + Math.sin(reflectAngle) * radius * 2.5);
            ctx.stroke();
        }
    }

    // ================== åœºæ™¯ 2: æŠ˜å°„ (é€é•œèšç„¦) ==================
    function drawRefraction() {
        const cx = width/2;
        const cy = height/2;
        const r = 120;
        const ior = 1.6; // ç»ç’ƒæŠ˜å°„ç‡

        // ç”»ç»ç’ƒçƒ
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.strokeStyle = '#444'; ctx.lineWidth=2; ctx.stroke();
        ctx.fillStyle = 'rgba(20, 20, 30, 0.5)'; ctx.fill();

        const rayCount = 300;
        ctx.lineWidth = 1;
        ctx.strokeStyle = `rgba(${scenes[1].color}, 0.1)`;

        // å…‰æºä½ç½®
        let lx = mouseX;
        let ly = mouseY;

        for (let i = 0; i < rayCount; i++) {
            // å…‰æŸå‘æ•£ç‚¹ (é¼ æ ‡ä½ç½®)
            let angleSpread = (i / rayCount - 0.5) * 1.5; // å…‰æŸå‘æ•£è§’
            let baseAngle = Math.atan2(cy - ly, cx - lx);
            let angle = baseAngle + angleSpread * 0.5; // ç¨å¾®èšæ‹¢ä¸€ç‚¹çš„å…‰æŸ

            // 1. å…¥å°„ç‚¹æ£€æµ‹ (Ray-Sphere Intersection)
            // ç®€åŒ–ï¼šå‡è®¾å…‰çº¿æ‰“åœ¨çƒä½“å·¦ä¾§è¡¨é¢
            // ä¸ºäº†è§†è§‰æ¼”ç¤ºï¼Œæˆ‘ä»¬åªè®¡ç®—èƒ½ç©¿é€çš„é‚£éƒ¨åˆ†å…‰çº¿
            
            // è¿™é‡Œç”¨ç®€åŒ–çš„é€é•œæ¨¡æ‹Ÿï¼šå…‰çº¿è¶Šé è¿‘è¾¹ç¼˜ï¼ŒåæŠ˜è¶Šå¤§
            // å…¥å°„å‘é‡
            let dx = Math.cos(angle);
            let dy = Math.sin(angle);
            
            // å‡è®¾å‡»ä¸­çƒä½“ä¸­å¿ƒå¹³é¢ (ç®€åŒ–è§†è§‰æ¨¡å‹)
            // çœŸå® RayTracing éœ€è¦è§£äºŒæ¬¡æ–¹ç¨‹ï¼Œè¿™é‡Œæ¨¡æ‹Ÿç»“æœ
            
            let distToCenter = Math.random() * 20; // æŠ–åŠ¨ä¸€ä¸‹æ¶ˆé™¤æ‘©å°”çº¹
            
            // æ¨¡æ‹Ÿå…‰çº¿ç©¿è¿‡é€é•œ
            // è¶Šé è¿‘ä¸­å¿ƒ(axis)ï¼ŒåæŠ˜è¶Šå°ï¼›è¶Šé è¿‘è¾¹ç¼˜ï¼ŒåæŠ˜è¶Šå¤§
            // ç”¨ç®€å•çš„ y è½´è·ç¦»æ¨¡æ‹Ÿ
            let offset = (i - rayCount/2) * (r*1.8 / rayCount); 
            
            // æ—‹è½¬åæ ‡ç³»è®©å…‰æŸå¯¹å‡†çƒå¿ƒ
            let perpX = -Math.sin(baseAngle) * offset;
            let perpY = Math.cos(baseAngle) * offset;
            
            let hitX = cx - Math.cos(baseAngle)*r*0.8 + perpX;
            let hitY = cy - Math.sin(baseAngle)*r*0.8 + perpY;
            
            if (Math.sqrt(perpX*perpX + perpY*perpY) < r) {
                 // ç»˜åˆ¶å…¥å°„
                ctx.beginPath();
                ctx.moveTo(lx, ly);
                ctx.lineTo(hitX, hitY);
                
                // èšç„¦è®¡ç®—
                // å®Œç¾çš„é€é•œä¼šèšäºä¸€ç‚¹ï¼Œçƒé€é•œä¼šæœ‰çƒå·®(Spherical Aberration) -> è¿™å°±æ˜¯ç„¦æ•£ï¼
                // çƒå·®å…¬å¼æ¨¡æ‹Ÿï¼šåæŠ˜è§’éšç€ offset çš„å¹³æ–¹å¢åŠ 
                let aberration = (offset / r) * (offset / r) * 2.0; 
                let focusDist = 200 - aberration * 100; // è¾¹ç¼˜çš„å…‰èšç„¦å¾—æ›´è¿‘
                
                let outX = cx + Math.cos(baseAngle) * (r + focusDist) + perpX * 0.1; // æ”¶æŸ
                let outY = cy + Math.sin(baseAngle) * (r + focusDist) + perpY * 0.1;

                // å»¶é•¿çº¿
                let extX = outX + (outX - hitX) * 2;
                let extY = outY + (outY - hitY) * 2;

                ctx.lineTo(extX, extY);
                ctx.stroke();
            }
        }
    }

    // ================== åœºæ™¯ 3: è‰²æ•£ (æ£±é•œ) ==================
    function drawDispersion() {
        const cx = width/2;
        const cy = height/2;
        
        // ç”»ä¸ªæ£±é•œ (ä¸‰è§’å½¢)
        const size = 150;
        const p1 = {x: cx, y: cy - size};
        const p2 = {x: cx - size, y: cy + size*0.7};
        const p3 = {x: cx + size, y: cy + size*0.7};

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.closePath();
        ctx.strokeStyle = '#666'; ctx.lineWidth=2; ctx.stroke();
        ctx.fillStyle = 'rgba(20,20,20,0.8)'; ctx.fill();

        // å…‰æŸ
        const rayCount = 150;
        // çº¢ç»¿è“ä¸‰ç§æŠ˜å°„ç‡
        const iors = [
            {color: '#ff3333', n: 1.1}, // çº¢å…‰æŠ˜å°„ç‡å°
            {color: '#33ff33', n: 1.2}, // ç»¿å…‰ä¸­ç­‰
            {color: '#3333ff', n: 1.3}  // è“å…‰æŠ˜å°„ç‡å¤§ (å¼¯å¾—å‰å®³)
        ];

        let lx = mouseX; // å…‰æºX
        let ly = mouseY; // å…‰æºY
        
        // é™åˆ¶å…‰æºåœ¨å·¦ä¾§ä»¥å…é€»è¾‘å¤ªå¤æ‚
        if (lx > cx) lx = cx - 10;

        for (let i = 0; i < rayCount; i++) {
            let offset = (i / rayCount) * 40; // å…‰æŸåšåº¦
            let startY = ly + offset;
            
            // 1. å…¥å°„ç‚¹ (å‡è®¾æ‰“åœ¨å·¦è¾¹ p1-p2 è¾¹ä¸Š)
            // ç®€åŒ–å‡ ä½•è®¡ç®—: æ‰¾åˆ° y å¯¹åº”çš„ x
            // p1-p2 æ–œç‡
            let k = (p2.y - p1.y) / (p2.x - p1.x);
            let b = p1.y - k * p1.x;
            // x = (y - b) / k
            let hitX = (startY - b) / k;
            
            // åªæœ‰æ‰“åœ¨æ£±é•œä¸Šçš„å…‰æ‰ç®—
            if (hitX > p2.x && hitX < p1.x) {
                
                // ç»˜åˆ¶ç™½å…‰å…¥å°„
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx.lineWidth = 2;
                ctx.moveTo(lx - 200, startY + (ly-cy)*0.1); // ç¨å¾®æœ‰ç‚¹è§’åº¦
                ctx.lineTo(hitX, startY);
                ctx.stroke();

                // 2. è‰²æ•£ (åˆ†è£‚æˆä¸‰æŸ)
                iors.forEach(ior => {
                    ctx.beginPath();
                    ctx.strokeStyle = ior.color;
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.1; // é€æ˜åº¦

                    // æ¨¡æ‹ŸæŠ˜å°„è·¯å¾„
                    // è¿›æ£±é•œ
                    let refractInternalY = startY + (ior.n * 20) * (startY - cy)/200; 
                    let exitX = cx + (cx - hitX); // å¯¹ç§°åˆ°å³è¾¹ (ç®€åŒ–)
                    
                    // å‡ºæ£±é•œ (ç¬¬äºŒæ¬¡æŠ˜å°„ï¼Œè‰²æ•£æ‹‰å¤§)
                    let exitY = refractInternalY + (ior.n * 50); 
                    
                    // æœ€ç»ˆå°„å‡º
                    let finalX = width;
                    let finalY = exitY + (exitY - refractInternalY) * 5;

                    ctx.moveTo(hitX, startY);
                    ctx.lineTo(exitX, exitY);
                    ctx.lineTo(finalX, finalY);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                });
            }
        }
    }

    // ================== åœºæ™¯ 4: æ°´é¢ (åŠ¨æ€æ³¢çº¹) ==================
    function drawWater() {
        // æ°´é¢ç„¦æ•£é€šå¸¸æ˜¯å¤šå±‚æ­£å¼¦æ³¢å åŠ çš„ç»“æœ
        // è¿™é‡Œç”¨çº¿æ¡æ¨¡æ‹Ÿæ³¢çš„"èšç„¦çº¿"
        
        const cols = 60;
        const rows = 40;
        const cellW = width / cols;
        const cellH = height / rows;

        ctx.strokeStyle = `rgba(${scenes[3].color}, 0.15)`;
        ctx.lineWidth = 1.5;

        // ç»˜åˆ¶ä¸¤å±‚ç½‘æ ¼ï¼Œä»¥ä¸åŒé€Ÿåº¦ç§»åŠ¨ï¼Œæ¨¡æ‹Ÿæ°´æ³¢å¹²æ¶‰
        for (let l = 0; l < 2; l++) {
            let t = time * (l === 0 ? 1 : -0.8) + l*10;
            
            for (let r = 0; r < rows; r++) {
                ctx.beginPath();
                for (let c = 0; c <= cols; c++) {
                    let x = c * cellW;
                    let y = r * cellH;
                    
                    // æ ¸å¿ƒï¼šç”¨æ­£å¼¦æ³¢åç§»é¡¶ç‚¹
                    // ç„¦æ•£åœ¨äºï¼šçº¿æ¡å˜å¯†çš„åœ°æ–¹äº®ï¼Œå˜ç–çš„åœ°æ–¹æš—
                    
                    let offsetX = Math.sin(c * 0.2 + t) * 30 + Math.cos(r * 0.3 + t) * 20;
                    let offsetY = Math.cos(c * 0.3 - t) * 30 + Math.sin(r * 0.2 + t) * 20;
                    
                    // è®©é¼ æ ‡å¹²æ‰°æ°´æ³¢
                    let dist = Math.sqrt((x-mouseX)**2 + (y-mouseY)**2);
                    let influence = Math.max(0, 1 - dist/300);
                    offsetX += (x - mouseX) * influence * 0.5;
                    offsetY += (y - mouseY) * influence * 0.5;

                    if (c===0) ctx.moveTo(x + offsetX, y + offsetY);
                    else ctx.lineTo(x + offsetX, y + offsetY);
                }
                ctx.stroke();
            }
        }
        
        // å†ç”»ç«–å‘çš„çº¿ï¼Œå½¢æˆç½‘æ ¼
         for (let l = 0; l < 2; l++) {
            let t = time * (l === 0 ? 1 : -0.8) + l*10;
             for (let c = 0; c < cols; c++) {
                ctx.beginPath();
                for (let r = 0; r <= rows; r++) {
                    let x = c * cellW;
                    let y = r * cellH;
                    let offsetX = Math.sin(c * 0.2 + t) * 30 + Math.cos(r * 0.3 + t) * 20;
                    let offsetY = Math.cos(c * 0.3 - t) * 30 + Math.sin(r * 0.2 + t) * 20;
                    
                     let dist = Math.sqrt((x-mouseX)**2 + (y-mouseY)**2);
                    let influence = Math.max(0, 1 - dist/300);
                    offsetX += (x - mouseX) * influence * 0.5;
                    offsetY += (y - mouseY) * influence * 0.5;

                    if (r===0) ctx.moveTo(x + offsetX, y + offsetY);
                    else ctx.lineTo(x + offsetX, y + offsetY);
                }
                ctx.stroke();
            }
         }
    }

</script>
</body>
</html>